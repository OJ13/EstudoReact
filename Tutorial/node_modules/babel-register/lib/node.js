"use strict";

exports.__esModule = true;
exports.default = register;

var _cloneDeep = require("lodash/cloneDeep");

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _sourceMapSupport = require("source-map-support");

var _sourceMapSupport2 = _interopRequireDefault(_sourceMapSupport);

var _cache = require("./cache");

var registerCache = _interopRequireWildcard(_cache);

var _escapeRegExp = require("lodash/escapeRegExp");

var _escapeRegExp2 = _interopRequireDefault(_escapeRegExp);

var _extend = require("lodash/extend");

var _extend2 = _interopRequireDefault(_extend);

var _babelCore = require("babel-core");

var babel = _interopRequireWildcard(_babelCore);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_sourceMapSupport2.default.install({
  handleUncaughtExceptions: false,
  environment: "node",
  retrieveSourceMap: function retrieveSourceMap(source) {
    var map = maps && maps[source];
    if (map) {
      return {
        url: null,
        map: map
      };
    } else {
      return null;
    }
  }
});

registerCache.load();
var cache = registerCache.get();

var transformOpts = {};

var oldHandlers = {};
var maps = {};

function mtime(filename) {
  return +_fs2.default.statSync(filename).mtime;
}

function compile(filename) {
  var result = void 0;

  var opts = new _babelCore.OptionManager().init((0, _extend2.default)({ sourceRoot: _path2.default.dirname(filename) }, (0, _cloneDeep2.default)(transformOpts), { filename: filename }));

  if (opts === null) return null;

  var cacheKey = JSON.stringify(opts) + ":" + babel.version;

  var env = babel.getEnv(false);

  if (env) cacheKey += ":" + env;

  if (cache) {
    var cached = cache[cacheKey];
    if (cached && cached.mtime === mtime(filename)) {
      result = cached;
    }
  }

  if (!result) {
    result = babel.transformFileSync(filename, (0, _extend2.default)(opts, {
      babelrc: false,
      sourceMaps: "both",
      ast: false
    }));
  }

  if (cache) {
    cache[cacheKey] = result;
    result.mtime = mtime(filename);
  }

  maps[filename] = result.map;

  return result.code;
}

function registerExtension(ext) {
  var old = oldHandlers[ext] || oldHandlers[".js"] || require.extensions[".js"];

  require.extensions[ext] = function (m, filename) {
    var result = compile(filename);

    if (result === null) old(m, filename);else m._compile(result, filename);
  };
}

function hookExtensions(_exts) {
  Object.keys(oldHandlers).forEach(function (ext) {
    var old = oldHandlers[ext];
    if (old === undefined) {
      delete require.extensions[ext];
    } else {
      require.extensions[ext] = old;
    }
  });

  oldHandlers = {};

  _exts.forEach(function (ext) {
    oldHandlers[ext] = require.extensions[ext];
    registerExtension(ext);
  });
}

register({
  extensions: _babelCore.DEFAULT_EXTENSIONS
});

function register() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (opts.extensions) hookExtensions(opts.extensions);

  if (opts.cache === false) cache = null;

  delete opts.extensions;
  delete opts.cache;

  (0, _extend2.default)(transformOpts, opts);

  if (!transformOpts.ignore && !transformOpts.only) {
    transformOpts.ignore = [new RegExp("^(?!" + (0, _escapeRegExp2.default)(process.cwd()) + ").*" + (0, _escapeRegExp2.default)(_path2.default.sep + "node_modules" + _path2.default.sep), "i"), new RegExp("^" + (0, _escapeRegExp2.default)(process.cwd()) + "(?:" + _path2.default.sep + ".*)?" + (0, _escapeRegExp2.default)(_path2.default.sep + "node_modules" + _path2.default.sep), "i")];
  }
}
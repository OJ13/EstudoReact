"use strict";

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = buildConfigChain;

var _index = require("../index");

var babel = _interopRequireWildcard(_index);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _micromatch = require("micromatch");

var _micromatch2 = _interopRequireDefault(_micromatch);

var _files = require("./loading/files");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function buildConfigChain() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var filename = opts.filename ? _path2.default.resolve(opts.filename) : null;
  var builder = new ConfigChainBuilder(filename);

  try {
    builder.mergeConfig({
      type: "arguments",
      options: opts,
      alias: "base",
      dirname: process.cwd()
    });

    if (opts.babelrc !== false) {
      builder.findConfigs(filename);
    }
  } catch (e) {
    if (e.code !== "BABEL_IGNORED_FILE") throw e;

    return null;
  }

  return builder.configs.reverse();
}

var ConfigChainBuilder = function () {
  function ConfigChainBuilder(filename) {
    _classCallCheck(this, ConfigChainBuilder);

    this.configs = [];
    this.filename = filename;
    this.possibleDirs = null;
  }

  ConfigChainBuilder.prototype.shouldIgnore = function shouldIgnore(ignore, only, dirname) {
    if (!this.filename) return false;

    if (ignore && !Array.isArray(ignore)) {
      throw new Error(".ignore should be an array, " + JSON.stringify(ignore) + " given");
    }

    if (only && !Array.isArray(only)) {
      throw new Error(".only should be an array, " + JSON.stringify(only) + " given");
    }

    return ignore && this.matchesPatterns(ignore, dirname) || only && !this.matchesPatterns(only, dirname);
  };

  ConfigChainBuilder.prototype.matchesPatterns = function matchesPatterns(patterns, dirname) {
    var _this = this;

    var res = [];
    var strings = [];
    var fns = [];

    patterns.forEach(function (pattern) {
      var type = typeof pattern === "undefined" ? "undefined" : _typeof(pattern);
      if (type === "string") strings.push(pattern);else if (type === "function") fns.push(pattern);else res.push(pattern);
    });

    if (res.some(function (re) {
      return re.test(_this.filename);
    })) return true;
    if (fns.some(function (fn) {
      return fn(_this.filename);
    })) return true;

    if (strings.length > 0) {
      if (!this.possibleDirs) {
        this.possibleDirs = [];

        if (this.filename) {
          this.possibleDirs.push(this.filename);

          var current = this.filename;
          while (true) {
            var previous = current;
            current = _path2.default.dirname(current);
            if (previous === current) break;

            this.possibleDirs.push(current);
          }
        }
      }

      var absolutePatterns = strings.map(function (pattern) {
        var negate = pattern[0] === "!";
        if (negate) pattern = pattern.slice(1);

        return (negate ? "!" : "") + _path2.default.resolve(dirname, pattern);
      });

      if ((0, _micromatch2.default)(this.possibleDirs, absolutePatterns, { nocase: true }).length > 0) {
        return true;
      }
    }

    return false;
  };

  ConfigChainBuilder.prototype.findConfigs = function findConfigs(loc) {
    var _this2 = this;

    if (!loc) return;

    if (!_path2.default.isAbsolute(loc)) {
      loc = _path2.default.join(process.cwd(), loc);
    }

    (0, _files.findConfigs)(_path2.default.dirname(loc)).forEach(function (_ref) {
      var filepath = _ref.filepath,
          dirname = _ref.dirname,
          options = _ref.options;

      _this2.mergeConfig({
        type: "options",
        options: options,
        alias: filepath,
        dirname: dirname
      });
    });
  };

  ConfigChainBuilder.prototype.mergeConfig = function mergeConfig(_ref2) {
    var type = _ref2.type,
        options = _ref2.options,
        alias = _ref2.alias,
        loc = _ref2.loc,
        dirname = _ref2.dirname;

    if (!options) {
      return false;
    }

    if (this.filename && this.shouldIgnore(options.ignore, options.only, dirname)) {
      throw Object.assign(new Error("This file has been ignored."), { code: "BABEL_IGNORED_FILE" });
    }

    options = Object.assign({}, options);

    loc = loc || alias;

    var envKey = babel.getEnv();
    if (options.env) {
      var envOpts = options.env[envKey];
      delete options.env;

      this.mergeConfig({
        type: type,
        options: envOpts,
        alias: alias + ".env." + envKey,
        dirname: dirname
      });
    }

    this.configs.push({
      type: type,
      options: options,
      alias: alias,
      loc: loc,
      dirname: dirname
    });

    if (options.extends) {
      var extendsConfig = (0, _files.loadConfig)(options.extends, dirname);

      var existingConfig = this.configs.some(function (config) {
        return config.alias === extendsConfig.filepath;
      });
      if (!existingConfig) {
        this.mergeConfig({
          type: "options",
          alias: extendsConfig.filepath,
          options: extendsConfig.options,
          dirname: extendsConfig.dirname
        });
      }
      delete options.extends;
    }
  };

  return ConfigChainBuilder;
}();